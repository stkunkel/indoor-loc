/*
 * pwmsw.c: Setting PWM pulses
 * Author: Stephanie Kunkel
 */

/*
 * Includes
 */
#include <stdio.h>
#include <xil_io.h>
#include <unistd.h>
#include "../platform.h"
#include "pwm.h"
#include "pwmsw.h"

/*
 * Global Variables
 */
u32 stepAmount = 0;

/*
 * Function Prototypes
 */
int setAbsAngle(Joint joint, float dgr);
float stepsToAngle(u32 steps);
u32 angleToSteps(float dgr);
u32 getValReg(Joint joint);
u32 readPwmReg(u32 reg);
int writePwmReg(u32 reg, u32 value);

/*
 * Functions
 */

/*
 * Move to Absolute Angle
 */
int moveToAbsAngle(Joint joint, float dgr, unsigned int time_ms) {
	//Variables
	int status;
	u32 steps_goal;
	float cur_angle;

	//Get current value
	cur_angle = getAbsAngle(joint);

	//Go step by step


	//Return
	return PWM_SUCCESS;
}

/*
 * Get Absolute Angle
 * In: Joint
 * Returns angle
 */
float getAbsAngle(Joint joint) {
	//Variables
	u32 steps;

	//Get Steps
	steps = readPwmReg(getValReg(joint));

	//Convert to angle and return
	return stepsToAngle(steps);
}

/*
 * Set Absolute Angle
 * In: Joint, angle in degrees
 * Returns 0 if successful
 */
int setAbsAngle(Joint joint, float dgr) {
	//Variables
	u32 steps;
	int status;

	//Compute steps from angle (0 --> 0dgr, steps --> 180dgr)
	steps = angleToSteps(dgr);

	//Write to Register
	status = writePwmReg(getValReg(joint), steps);

	//Return
	return status;
}

/*
 * Convert Steps to Absolute Angle
 * In: Steps
 * Returns Angle in Degrees
 */
float stepsToAngle(u32 steps){
	return steps / stepAmount * 180.0;
}

/*
 * Convert Absolute Angle to Steps
 * In: Angle in Degrees
 * Returns Steps
 */
u32 angleToSteps(float dgr){
	return (u32) (dgr / 180 * stepAmount);
}

/*
 * Get value register for Joint
 * In: Joint
 * Returns register
 */
u32 getValReg(Joint joint) {
	switch (joint) {
	case base:
		return BASE_REG;
	case shoulder:
		return SHOULDER_REG;
	case elbow:
		return ELBOW_REG;
	case wrist:
		return WRIST_REG;
	case thumb:
		return THUMB_REG;
	case finger:
		return FINGER_REG;
	default:
		return -1;
	}
}

/*
 * Initialize PWM Module
 * In: Amount of steps
 * Returns 0 if successful
 */
int initPWM(u32 steps) {
	//Set steps
	writePwmReg(PWM_S00_AXI_SLV_REG6_OFFSET, steps);
	writePwmReg(PWM_S00_AXI_SLV_REG7_OFFSET, steps);
	writePwmReg(PWM_S00_AXI_SLV_REG8_OFFSET, steps);
	writePwmReg(PWM_S00_AXI_SLV_REG9_OFFSET, steps);
	writePwmReg(PWM_S00_AXI_SLV_REG10_OFFSET, steps);
	writePwmReg(PWM_S00_AXI_SLV_REG11_OFFSET, steps);

	//Set initial val --> 0 dgrs
	writePwmReg(PWM_S00_AXI_SLV_REG0_OFFSET, (u32) (steps / 2));
	writePwmReg(PWM_S00_AXI_SLV_REG1_OFFSET, (u32) (steps / 2));
	writePwmReg(PWM_S00_AXI_SLV_REG2_OFFSET, (u32) (steps / 2));
	writePwmReg(PWM_S00_AXI_SLV_REG3_OFFSET, (u32) (steps / 2));
	writePwmReg(PWM_S00_AXI_SLV_REG4_OFFSET, (u32) (steps / 2));
	writePwmReg(PWM_S00_AXI_SLV_REG5_OFFSET, (u32) (steps / 2));

	//Remember steps
	stepAmount = steps;

	//Return
	return PWM_SUCCESS;
}

/*
 * Read from Register of PWM Module
 * In: Register
 * Returns content of register
 */
u32 readPwmReg(u32 reg) {
	return PWM_mReadReg(PWMADDRESS, reg);
}

/*
 * Write to Register of PWM Module
 * In: Register, Value
 * Returns 0 if successful
 */
int writePwmReg(u32 reg, u32 value) {
	//Write value to register
	PWM_mWriteReg(PWMADDRESS, reg, value);

	//Check if value written correctly
	if (readPwmReg(reg) == value) {
		return PWM_SUCCESS;
	} else {
		return PWM_REG_CONT_NO_MATCH;
	}
}

/*
 * PWM control
 */
int pwm(int amount) {
	//variables
	unsigned int a, i;
	u32 val;

	//set steps to PWMSTEPS
	writePwmReg(PWM_S00_AXI_SLV_REG6_OFFSET, PWMSTEPS);
	writePwmReg(PWM_S00_AXI_SLV_REG7_OFFSET, PWMSTEPS);
	writePwmReg(PWM_S00_AXI_SLV_REG8_OFFSET, PWMSTEPS);
	writePwmReg(PWM_S00_AXI_SLV_REG9_OFFSET, PWMSTEPS);
	writePwmReg(PWM_S00_AXI_SLV_REG10_OFFSET, PWMSTEPS);
	writePwmReg(PWM_S00_AXI_SLV_REG11_OFFSET, PWMSTEPS);

	//main loop
	for (a = 0; a <= amount; a++) {
		//LED1
		writePwmReg(PWM_S00_AXI_SLV_REG1_OFFSET, PWMSTEPS / 2);

		//LED2
		writePwmReg(PWM_S00_AXI_SLV_REG2_OFFSET, PWMSTEPS / 10);

		//LED3
		writePwmReg(PWM_S00_AXI_SLV_REG3_OFFSET, PWMSTEPS);

		//LED0
		for (i = 0; i <= PWMSTEPS; i = i + PWMSTEPS / 5) {
			writePwmReg(PWM_S00_AXI_SLV_REG0_OFFSET, i);
		}
	}

	//finish
	return 0;
}
