/*
 * test.c: Test functions
 * Author: Stephanie Kunkel
 */


/*
 * Test Position Update function
 */
void testPositionUpdate() {
//Variables
	const short accel_axis = 2;
	const short rot_axis = 0;
	int i;
	float l_accel_conv[NUMBER_OF_AXES] = { 0.0, 0.0, 0.0 };
	float l_quat_conv[QUATERNION_AMOUNT] = { 1.0, 0.0, 0.0, 0.0 };
	unsigned long l_timestamp = 0;
	unsigned long l_recent_ts = 0;
	Vector l_recentAccelInertial = { .value[0] = 0.0, .value[1] = 0.0, .value[2
			] = 0.0 };
	Vector l_recentVelocity = { .value[0] = 0.0, .value[1] = 0.0, .value[2
			] = 0.0 };
	Vector l_recentPosition = { .value[0] = 0.0, .value[1 ] = 0.0, .value[2
			] = 0.0 };

//WITHOUT ROTATION
//Set gravity
	gravity_calibrated.value[GRAVITY_AXIS] = 1.0;
	l_accel_conv[GRAVITY_AXIS] = 1.0;

//Only gravity for two periods
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}

//Acceleration of 1m/s^2
	l_accel_conv[accel_axis] += 1.0;
	l_timestamp += (1000 / DMP_FIFO_RATE);
	updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
			&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
			&l_recent_ts);
	printPosition(&l_recentPosition);
	myprintf("\r\n");

//Only gravity for two periods
	l_accel_conv[accel_axis] -= 1.0;
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}
//Acceleration of -1m/s^2
	l_accel_conv[accel_axis] += -1.0;
	l_timestamp += (1000 / DMP_FIFO_RATE);
	updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
			&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
			&l_recent_ts);
	printPosition(&l_recentPosition);
	myprintf("\r\n");

//Only gravity for two periods
	l_accel_conv[accel_axis] += 1.0;
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}

//WITH ROTATION
	myprintf("Rotation: 180°\r\n");

//Rotate 180°
	l_quat_conv[0] = 0;
	l_quat_conv[rot_axis + 1] = 1;

//construct accel
	for (i = 0; i < NUMBER_OF_AXES; i++) {
		//gravity
		if (i == GRAVITY_AXIS) {
			l_accel_conv[i] = -1.0;
		} else {
			l_accel_conv[i] = 0.0;
		}
	}

//Reset data
	l_recent_ts = 0;
	l_timestamp = 0;
	for (i = 0; i < NUMBER_OF_AXES; i++) {
		l_recentAccelInertial.value[i] = 0.0;
		l_recentPosition.value[i] = 0.0;
		l_recentVelocity.value[i] = 0.0;
	}

//Only gravity for two periods
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}

//Acceleration of 1m/s^2
	l_accel_conv[accel_axis] += 1.0;
	l_timestamp += (1000 / DMP_FIFO_RATE);
	updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
			&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
			&l_recent_ts);
	printPosition(&l_recentPosition);
	myprintf("\r\n");

//Only gravity for two periods
	l_accel_conv[accel_axis] -= 1.0;
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}
//Acceleration of -1m/s^2
	l_accel_conv[accel_axis] += -1.0;
	l_timestamp += (1000 / DMP_FIFO_RATE);
	updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
			&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
			&l_recent_ts);
	printPosition(&l_recentPosition);
	myprintf("\r\n");

//Only gravity for two periods
	l_accel_conv[accel_axis] += 1.0;
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}

//WITH ROTATION
	myprintf("Rotation: 90°\r\n");

//Rotate 90°
	l_quat_conv[0] = 0.7071067811865475;
	l_quat_conv[rot_axis + 1] = 0.7071067811865475;

//Construct accel
	for (i = 0; i < NUMBER_OF_AXES; i++) {
		//gravity
		if (i == GRAVITY_AXIS) {
			l_accel_conv[i] = 1.0;
		} else {
			l_accel_conv[i] = 0.0;
		}
	}

//Set accel (rotate using rotation matrix)
	vectorToFloatArray(
			multMatrixAndVector(toRotationMatrix(l_quat_conv),
					toVector(l_accel_conv)), l_accel_conv);

//Reset data
	l_recent_ts = 0;
	l_timestamp = 0;
	for (i = 0; i < NUMBER_OF_AXES; i++) {
		l_recentAccelInertial.value[i] = 0.0;
		l_recentPosition.value[i] = 0.0;
		l_recentVelocity.value[i] = 0.0;
	}

//Only gravity for two periods
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}

//Acceleration of 1m/s^2
	l_accel_conv[accel_axis] += 1.0;
	l_timestamp += (1000 / DMP_FIFO_RATE);
	updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
			&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
			&l_recent_ts);
	printPosition(&l_recentPosition);
	myprintf("\r\n");

//Only gravity for two periods
	l_accel_conv[accel_axis] -= 1.0;
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}
//Acceleration of -1m/s^2
	l_accel_conv[accel_axis] += -1.0;
	l_timestamp += (1000 / DMP_FIFO_RATE);
	updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
			&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
			&l_recent_ts);
	printPosition(&l_recentPosition);
	myprintf("\r\n");

//Only gravity for two periods
	l_accel_conv[accel_axis] += 1.0;
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}

	//WITH ROTATION
	myprintf("Rotation: 45°\r\n");

	//Rotate 45°
	l_quat_conv[0] = 0.9238795325112867;
	l_quat_conv[rot_axis + 1] = 0.3826834323650897;

	//Construct accel
	for (i = 0; i < NUMBER_OF_AXES; i++) {
		//gravity
		if (i == GRAVITY_AXIS) {
			l_accel_conv[i] = 1.0;
		} else {
			l_accel_conv[i] = 0.0;
		}
	}

	//Set accel (rotate using rotation matrix)
	vectorToFloatArray(
			multMatrixAndVector(toRotationMatrix(l_quat_conv),
					toVector(l_accel_conv)), l_accel_conv);

	//Reset data
	l_recent_ts = 0;
	l_timestamp = 0;
	for (i = 0; i < NUMBER_OF_AXES; i++) {
		l_recentAccelInertial.value[i] = 0.0;
		l_recentPosition.value[i] = 0.0;
		l_recentVelocity.value[i] = 0.0;
	}

	//Only gravity for two periods
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}

	//Acceleration of 1m/s^2
	l_accel_conv[accel_axis] += 1.0;
	l_timestamp += (1000 / DMP_FIFO_RATE);
	updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
			&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
			&l_recent_ts);
	printPosition(&l_recentPosition);
	myprintf("\r\n");

	//Only gravity for two periods
	l_accel_conv[accel_axis] -= 1.0;
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}
	//Acceleration of -1m/s^2
	l_accel_conv[accel_axis] += -1.0;
	l_timestamp += (1000 / DMP_FIFO_RATE);
	updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
			&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
			&l_recent_ts);
	printPosition(&l_recentPosition);
	myprintf("\r\n");

	//Only gravity for two periods
	l_accel_conv[accel_axis] += 1.0;
	for (i = 1; i <= 2; i++) {
		l_timestamp += (1000 / DMP_FIFO_RATE);
		updatePosition(l_accel_conv, l_quat_conv, &l_timestamp,
				&l_recentAccelInertial, &l_recentVelocity, &l_recentPosition,
				&l_recent_ts);
		printPosition(&l_recentPosition);
		myprintf("\r\n");
	}

}
